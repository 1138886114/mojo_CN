# 函数
Mojo 支持两种类型的函数：def 和 fn 函数。您可以将任一声明与任何函数（包括 main() 函数）一起使用，但它们具有不同的默认行为，如本页所述。

我们相信def和fn都有很好的用例，并且不认为其中任何一个比另一个更好。决定使用哪种风格取决于个人喜好，哪种风格最适合特定任务。

我们相信 Mojo 在这方面的灵活性是一种超能力，它允许您以最适合您的项目的方式编写代码。

> 注意： 在 struct 内声明的函数称为“方法”，  
但它们具有与此处描述的“函数”相同的品质。< /span>


## def 函数
def 函数提供与 Python def 函数相同的活力和灵活性。 例如，该函数在 Python 和 Mojo 中的工作方式相同：
```
def greet(name):
    greeting = "Hello, " + name + "!"
    return greeting
```

在 Mojo 中，您还可以选择指定参数类型、返回类型和变量可变性，如下所示：
```
def greet(name: String) -> String:
    let greeting = "Hello, " + name + "!"
    return greeting
```
这样，编译器可以确保 name 是字符串，返回类型是字符串，并且greeting 变量不能发生变化。

以下是有关 def 的所有信息：
- 参数不需要声明类型。

- 未声明的参数实际上作为对象传递，这允许函数接收任何类型（Mojo 在运行时推断类型）。

- 返回类型不需要声明，也默认为object。

- 参数是可变的（通常按值传递，使用拥有的参数约定）。

- 如果参数是对象类型，则按照对象引用语义将其作为引用接收。

- 如果参数是任何其他声明的类型，则它将作为值接收（使用拥有的参数约定）。

- 变量不需要声明为可变 (var) 或不可变 (let)； 它们默认是可变的。

## object类型
如果您没有在 def 中声明参数或返回值的类型，它就会成为一个对象，这与标准库中的任何其他类型不同。

对象类型允许动态类型，因为它实际上可以表示 Mojo 标准库中的任何类型，并且实际类型是在运行时推断的。 （实际上，在它能够表示所有 Mojo 类型之前，还有更多工作要做。）这对于与 Python 的兼容性以及它为动态类型提供的所有灵活性非常有用。 但是，当函数接收或返回意外类型时，缺乏类型强制可能会导致运行时错误。

为了与 Python 兼容，使用对象引用语义传递对象值。 因此，对象类型与强制值语义的参数约定不兼容。 因此，如果将对象值与其他强类型值一起使用，请务必小心 - 它们的行为可能会不一致，因为对象是标准库中唯一不符合完整值语义的类型。

## fn函数
fn 函数提供严格的类型检查和额外的内存安全性。 它基本上迫使您在 def 中编写可选的内容，并确保您不会意外地改变收到的参数。 例如，下面是使用 fn 的与上面相同的函数：
```
fn greet(name: String) -> String:
    let greeting = "Hello, " + name + "!"
    return greeting
```
就函数调用者而言，def 和 fn 函数是可以互换的。 也就是说，def 能做的事 fn 做不到（反之亦然）。 不同之处在于，与 def 函数相比，fn 函数内部更加严格。

以下是有关 fn 的所有信息：
- 参数必须指定类型（结构体方法中的 self 参数除外）。

- 返回值必须指定类型，除非函数不返回值。

- 如果不指定返回类型，则默认为 None （意味着没有返回值）。

- 默认情况下，参数作为不可变引用接收（值是只读的，使用借用参数约定）。

- 这可以防止意外突变，并允许使用不可复制的类型作为参数。

- 如果您想要本地副本，只需将值分配给本地变量即可。 或者，您可以通过声明 inout 参数约定来获取对该值的可变引用）。

- 变量必须声明为可变 (var) 或不可变 (let)。

- 如果函数引发异常，则必须使用 raises 关键字显式声明。 （def 函数不需要声明异常。）

通过强制执行这些类型检查，使用 fn 函数有助于避免各种运行时错误。与 def 函数中的动态类型相比，它还提高了性能，因为不需要进行额外处理来确定运行时要使用的数据类型 - 类型在编译时是固定的。

## 可选参数
可选参数是包含默认值的参数，例如此处的 exp 参数：
```
fn pow(base: Int, exp: Int = 2) -> Int:
    return base ** exp

fn use_defaults():
    # Uses the default value for `exp`
    let z = pow(3)
    print(z)
```
但是，您不能为声明为 inout 的参数定义默认值。

## 关键字参数
您还可以使用参数名称指定参数值：
```
fn pow(base: Int, exp: Int = 2) -> Int:
    return base ** exp

fn use_keywords():
    # Uses keyword argument names (with order reversed)
    let z = pow(exp=3, base=2)
    print(z)
```
> 注意：Mojo 目前仅部分支持关键字参数，因此尚不支持某些功能，例如仅关键字参数和可变关键字参数（例如 **kwargs）。

## 重载函数
如果 def 函数未指定参数类型，则它可以接受任何数据类型并决定如何在内部处理每种类型。当您想要仅通过接受任意输入来工作的富有表现力的 API 时，这很好，因此通常不需要为 def 函数编写函数重载。

另一方面，所有 fn 函数都必须指定参数类型，因此如果您希望函数使用不同的数据类型，则需要实现该函数的单独版本，每个版本指定不同的参数类型。 这称为函数“重载”。
例如，下面是一个重载的 add() 函数，它可以接受 Int 或 String 类型：
```
fn add(x: Int, y: Int) -> Int:
    return x + y

fn add(x: String, y: String) -> String:
    return x + y
```
如果将 Int 或 String 以外的任何内容传递给 add() 函数，您将收到编译器错误。 也就是说，除非 Int 或 String 可以将类型隐式转换为它们自己的类型。 例如，String 包含其构造函数 (__init__()) 的重载版本，该构造函数接受 StringLiteral 值。 因此，您还可以将 StringLiteral 传递给需要 String 的函数。

解析重载函数调用时，Mojo 编译器会尝试每个候选函数并使用有效的函数（如果只有一个版本有效），或者选择最接近的匹配（如果可以确定紧密匹配），或者报告调用 是不明确的（如果它无法弄清楚选择哪一个）。

如果编译器无法确定要使用哪个函数，您可以通过将值显式转换为支持的参数类型来解决歧义。 例如，在下面的代码中，我们想要调用重载的 foo() 函数，但是两个实现都接受一个支持从 StringLiteral 隐式转换的参数。 因此，对 foo(string) 的调用是不明确的，并且会产生编译器错误。 我们可以通过将值转换为我们真正想要的类型来修复它：
```
@value
struct MyString:
    fn __init__(inout self, string: StringLiteral):
        pass

fn foo(name: String):
    print("String")

fn foo(name: MyString):
    print("MyString")

fn call_foo():
    let string = "Hello"
    # foo(string) # This call is ambiguous because two `foo` functions match it
    foo(MyString(string))
```
解析重载函数时，Mojo 不会考虑调用站点的返回类型或其他上下文信息 - 只有参数类型会影响选择哪个函数。

重载也适用于 fn 和 def 函数的组合。 例如，您可以定义多个 fn 函数重载，然后定义一个或多个未指定所有参数类型的 def 版本，作为后备。

> 注意：虽然我们还没有讨论参数（它们与函数参数不同，用于编译时元编程），但您也可以根据参数类型重载函数。